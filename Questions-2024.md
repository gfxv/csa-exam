Содержание:
- [[#Основной материал |Вопросы по основному материалу]]
- [[#Материал семинаров |Вопросы по материалу семинаров]]
- [[#Ответы]]


# Основной материал

[[#1. Что такое компьютерная система? Отличие информационной и управляющей системы? Почему большинство современных компьютерных систем считаются системами с преобладающей программной составляющей? Примеры. Понятие информационного процессора.]]

[[#2. Системная инженерия. Понятие системы. Варианты рассмотрения систем. Модульность. Жизненный цикл. Операционное окружение и обеспечивающие системы. Заинтересованные стороны (stakeholders). Проблема передачи информации при разработке компьютерных систем.]]

[[#3. Цели и задачи архитектурного проектирования компьютерных систем, его эффект. Понятие архитектуры. Различные трактовки (Гради Буч, ISO 42010 и д.р.) и их практическая значимость.]]

[[#4. Реле как базис компьютерной системы. Область применения и принципы построения систем на базе реле. Примеры релейных схем и принцип их функционирования. Программируемые логические контроллеры (ПЛК). Область применения. Особенности аппаратуры и программирования по сравнению с компьютерами общего назначения.]]

[[#5. Принципы кодирования информации в компьютерных системах. Двоичный код, достоинства и недостатки. Машинное слово и адресация. Код грея, BCD, Base64, Base58.]]

[[#6. Что такое комбинационная схема? Построение через таблицу истинности и алгоритмизацию. Состояние и параллелизм, переходные процессы. Состояние `x` и `z`. Особенности поведения комбинационных схем по сравнению с программами. Реализация "условного оператора". Программируемые логические интегральные схемы (ПЛИС) и их устройство.]]

[[#7. 2-этапное производство. Понятия Hardware и Software, их свойства. Сравнение с понятиями программного и аппаратного обеспечения. Проблемы, специфичные для аппаратного обеспечения производство, эксплуатация, устаревание. Принципы совместного проектирование (HW/SW CoDesign).]]

[[#8. Понятие модели вычислений (MoC). Сопоставление понятия парадигмы программирования и MoC. Примеры MoC (последовательные, параллельные, функциональные) и их роль в разработке компьютерных систем. Использование MoC в разных вычислительных платформах.]]

[[#9. Универсальный процессор и его свойства. Машина Тьюринга и полнота по Тьюрингу. Виды процессоров (СБИС, FPGA, CGRA, GPU, DSP, CPU) и их сопоставление с точки зрения универсальности и эффективности.]]

[[#10. Архитектура фон Неймана. Принципы. Свойства. Особенности и ограничения. Применение на практике. Машинное слово. Понятие системы команд и её роль в построении процессоров. Control Unit и DataPath.]]

[[#11. Гарвардская архитектура и её отличия от архитектуры фон Неймана. Принципы. Свойства. Особенности и ограничения. Применение на практике. Подходы к обходу ограничений архитектуры. Машинное слово. Control Unit и DataPath.]]

[[#12. Механизм микроопераций, микропрограммирование и его роль в развитии компьютерных систем. Особенности и ограничения. Применение на практике. Пример оптимизации через микрокод. NISC архитектура.]]

[[#13. Что такое CISC? Роль в развитии компьютерных систем. Применение на практике. Достоинства и недостатки. Отличия от архитектуры фон Неймана. Особенности программирования.]]

14. Что такое RISC? Роль в развитии компьютерных систем. Применение на практике. Достоинства и недостатки. Отличия от архитектуры фон Неймана. Особенности программирования.
15. Конвейеризированное исполнение команд. Стадии конвейера. Виды конфликтов (по данным, по управлению), их примеры и влияние на производительность. Достоинства и недостатки.
16. Виды конфликтов при работе конвейера и механизмы их разрешения, сокращения их числа. Пузырёк, разворачивание циклов, предсказания переходов (статические и динамические).
17. Что такое SOP (Stack-Oriented Processors, стековый процессор)? Роль в развитии компьютерных систем. Применение на практике. Достоинства и недостатки. Отличия от архитектуры фон Неймана. Особенности программирования.
18. Поддержка операций ввода-вывода в фон Неймановских процессорах. Поддержка на уровне системы команд (порт, отображение в память). Программно-управляемый ввод-вывод. Ввод-вывод через механизм прерываний. Механизм прямого доступа к памяти.
19. Параллелизм уровня задач. Кооперативная многозадачность. Принцип работы и подходы к реализации. Примеры использования. Достоинства и ограничения. Зелёные процессы. Проблема синхронизации процессов по управлению и по данным. Сравнение с альтернативами.
20. Параллелизм уровня задач. Вытесняющая многозадачность. Механизмы переключения задач. Примеры использования. Достоинства и ограничения. Проблема синхронизации процессов по управлению и по данным. Сравнение с альтернативами.
21. Система прерываний. Виды прерываний. Механизм обработки прерываний по шагам. Задачи, решаемые механизмом прерываний. Сторожевой таймер.
22. Параллелизм уровня задач. Проблемы совмещения, изоляции и взаимодействия задач между собой. Методы разрешения данных проблем (с точки зрения опыта программиста и пользователя): распределение по адресному пространству, банки памяти, сегментная организация памяти и виртуальная память.
23. Сегментная и виртуальная память. Решаемые задачи и принципы работы. Проблема фрагментации. Достоинства и недостатки.
24. Иерархия памяти (явная и скрытая). Виды памяти. Особенности использования на практике. Устройство памяти с произвольным доступом. Устройство и принцип работы ROM, SRAM, DRAM ячеек.
25. Механизм кеширования в компьютерных системах, принцип локальности. Функционирование кеш памяти процессора (чтение, запись). Виды кеш промахов. Механизм вытеснения (LRU, PLRU).
26. Устройство кеш-памяти процессора. Ассоциативность кеш-памяти (полностью ассоциативная, прямое отображение, множественно-ассоциативный кеш). Принципы работы. Детальное описание принципов работы кеш-памяти с разными вариантами ассоциативности.
27. Иерархия кеш-памяти процессора. Разделённый/унифицированный, включающий/исключающий, частный/общий. Причины множества уровней кеша. Типовые уровни кеша в современных процессорах.
28. Когерентность кеш-памяти. Возможные состояния кеш линий. Механизмы обмена информацией между кешами: справочник, отслеживание и перехват. CAP теорема.
29. Закон Мура. Закон Деннарда. Закон Амдала. Power-wall. Memory-wall. Их роль в развитии компьютерных систем. Источники роста производительности процессоров тогда и сегодня.
30. Проблема обеспечения реального времени в современных компьютерных системах. Влияние параллелизма уровня инструкций, языков программирования высокого уровня, многозадачности и организации памяти.
31. Уровневая организация компьютерных систем. Элементы уровня организации. Уровневый архитектурный стиль. Примеры. Явление разделения на уровни (disaggregation) и их смешения. Документирование инструментальных цепочек.
32. Особенности реализации структурного программирования в фон Неймановских процессорах. Работа с памятью, регистрами. Реализация процедур. Реентерабельность. Рекурсия. Реализация условного оператора и циклов.
33. Уровни параллелизма. Параллелизм уровня бит. Низкоуровневый параллелизм. Параллелизм уровня инструкций. Параллелизм уровня задач. Примеры и особенности.
34. Параллелизм уровня инструкций. Суперскалярные процессора. Особенности и принципы работы. Сравнение с VLIW и практика использования. Достоинства и недостатки. Барьеры памяти.
35. Параллелизм уровня инструкций. VLIW процессора. Особенности и принципы работы. Сравнение с суперскалярными и практика использования. Достоинства и недостатки. Барьеры памяти.
36. Классификация Флинна. Выделяемые классы и примеры машин этих классов. SIMT архитектура.
37. Классификация Дункана. Цели и задачи, классификация первого уровня. Синхронные архитектуры (векторные, SIMD, ассоциативные массивы, систолические). Принципы их работы и примеры.
38. Классификация Дункана. Цели и задачи, классификация первого уровня. MIMD архитектуры (распределённая и разделяемая память). Примеры и принципы их работы.
39. Классификация Дункана. Цели и задачи, классификация первого уровня. MIMD парадигмы (MIMD/SIMD, потоки данных, редукционные, wavefront). Примеры и принципы их работы.
40. CGRA процессора. Особенности и место в индустрии. Пространственные (spatial) и временные (temporal) вычисления. Примеры и принципы их работы.

# Материал семинаров

1. Модель организации памяти в CUDA-совместимых GPU. Организация доступа к памяти между разными потоками. Ручная и автоматическая оптимизация операций с памятью. (Афанасьев Кирилл Александрович)
2. Методы тестирования пользовательских интерфейсов: A/B-тестирование, юзабилити-тестирование, карточная сортировка. Сценарии использования, характерные черты, сходства и различия. (Башаримов Евгений Александрович)
3. Cверточные нейронные сети (CNN) - архитектура и применения. (Качанов Даниил Владимирович)
4. Опишите механизмы защиты, используемые в Linux: Discretionary Access Control, Role Based Access Control. Их уязвимости. (Емелин Даниил Игоревич)
5. Основные методы оптимизации запросов в GraphQL: фрагменты, кэширование, пакетная отправка, сохраненные запросы. Принцип работы и влияние на эффективность клиент-серверного взаимодействия. (Наземцев Сергей Дмитриевич)
6. Расскажите об алгоритме кластеризации данных K-means. Недостатки, связанные с количеством кластеров и начальным выбором их центров. Методы выбора начального приближения центров. (Васина Дарья Анатольевна)
7. Основные алгоритмы сборки мусора в JVM: Serial, Parallel, Concurrent Mark Sweep, G1, ZGC. (Федоров Егор Владимирович)
8. Throughput vs latency tradeoff при выборе GC. (Бардин Петр Алексеевич)
9. Какие типы инструкций использует виртуальная машина Ethereum (EVM) и как они влияют на выполнение смарт-контрактов? (Шишминцев Дмитрий Владимирович)
10. Система отслеживания ошибок в языке Erlang связана с Supervision Tree для обеспечения надёжности. Объясните, как происходит автоматическое восстановление работы системы после сбоев. (Лянгузов Дмитрий Максимович)
11. Одним из этапов генетического алгоритма является мутация особей. Расскажите про мутационную вероятность, каким образом её значение влияет на поисковое пространство? (Рыков Степан Олегович)
12. Расскажите принцип работы следующих методов формальной верификации смарт-контрактов: Model Checking, Symbolic execution, Theorem proving. (Хабнер Георгий Евгеньевич)
13. Аналоговые вычисления. Элементная база, особенности. Хранение и обработка взвешенной матрицы в твердотельном накопителе на аналоговой схеме Mythic. (Балин Артем Алексеевич)
14. В компиляторах на базе LLVM исходный код проходит через цепочку представлений: Абстрактное синтаксическое дерево(AST); Промежуточное представление LLVM (LLVM IR); Платформенно-ориентированный код (Assembly). Опишите трансформации, происходящие c IR и как реализованы переходы между представлениями в этой цепи. (Хороших Дмитрий Максимович)
15. Принципы создания криптостойких шифров. Атаки, эксплуатирующие уязвимости в шифрах. Атака Воденэ на блочный шифр в режиме Cipher Block Chaining. (Манухин Константин Александрович)
16. Какие алгоритмы сжатия данных используются в аудиокодеках с потерями, таких как MP3 и AAC, и как они отличаются от методов без потерь, таких как FLAC и ALAC? (Колмаков Дмитрий Владимирович)
17. B-tree и hash индексы в базах данных. Устройство, преимущества и недостатки. (Бадамханов Тимур Шухратович)
18. Shortcut learning в нейронных сетях. Спосбы противодействия: доменная адаптация, stratified evaluations, shifted evaluations и contrastive evaluations. (Касьяненко Вера Михайловна)
19. Объекты в распределенной трассировке микросервисных систем. Span, trace и другие составляющие. (Шевченко Дарья Павловна)
20. Объясните назначение и взаимосвязь компонентов кластера kubernetes (API server, etcd, Scheduler, Controller Manager, kubelet, kube-proxy, Container runtime). (Султанов Артур Радикович)
21. Примитивы Concurrency в Go: горутины, каналы, блокировки, мьютексы. Расскажите, что такое состояние гонки и принцип работы ключа -race. (Бушмелев Константин Алексеевич)
22. Ключевые архитектурные отличия специализированных процессоров NPU и TPU по сравнению с GPU. Набор инструкций. Архитектура памяти. Дизайн ядер (вычислительных блоков). Тип памяти и доступ к ней. (Соколов Анатолий Владимирович)
23. Meltdown — одна из самых серьезных уязвимостей микропроцессоров, расскажите: что это за уязвимость, на чем она основана и что является объектом атаки? (Мальков Павел Александрович)
24. Для чего применяется технология Intel Software Guard Extensions (Intel SGX)? На чём базируется дизайн приложения с Intel SGX? Уязвимость AEPIC Leak. (Ляшенко Никита Андреевич)
25. Квантование в контексте машинного обучения - это процесс уменьшения точности вычислений, который позволяет уменьшить требования к ресурсам при выполнении моделей. PTQ и QAT - это два основных подхода к квантованию. Какие преимущества и недостатки методов квантования Post-Training Quantization (PTQ) и Quantization-Aware Training (QAT)? (Маликов Глеб Игоревич)
---
---
# Ответы
## Основной материал

### 1. Что такое компьютерная система? Отличие информационной и управляющей системы? Почему большинство современных компьютерных систем считабются системами с преобладающей программной составляющей? Примеры. Понятие информационного процессора.

**Компьютерная система** (для данного курса) -- любые системы (*любое устройство или группа взаимосвязанных или смежных устройств*), оснащённые внутренними алгоритмами управления.
Примеры:
- светодиодная лампа;
- кабели для зарядки мобильных телефонов;
- часы и, конечно, умные часы;
- интерактивные детские игрушки;
- автомобиль и беспилотный автомобиль;
- станок;
- дверной замок;
- и т.п.

**Информационные системы:**
- Получает данные снаружи
- Как-то их обрабатывает, работает с ними и тд
- Отдаёт результат

Особенности
- Должны работать быстро (чтобы пользователь долго не ждал)
- Спекулятивные вычисления
- Параллелизм

**Управляющие системы:**
- взаимодействия с реальным миром
- для контроля и управления

Особенности
- в реальном времени
	- реальное время != быстро | отсутствие сбоев | абсолютная точность
	- реальное время == предсказуемо и в заданное время
	- должно работать строго с тем расписанием, с которым его задумали
	- `пример про ГЭС`
- встроенное исполнение
	- не "универсальна", а прикручена к объекту управления
	- интеграция в реальный мир (пример: если находится на улице -- сделать защиту от дождя и снега)
	- специализация функций, платформы, аппаратуры
	- ограниченные ресурсы (как правило про энергопотребления)
- автономная эксплуатация
	- без подключения к сети питания
	- без возможности обслуживания людьми

Пример: Лампочка. Контроллер управляет свечением. Может адаптироваться к текущему освещению и тд.

Большинство современных компьютерных систем -- **программные**
Наибольшие затраты идут на разработку, написания кода и поддержку. Легко поправить, докрутить. НО вся сложность разрабатываемой системы воплощается через SW. (+ можно привести пример про Minix ?)

**Информационные процессоры** — это устройства, которые предназначены для обработки информации. Основная задача информационных процессоров — это преобразование входных данных в выходные с использованием определенных алгоритмов.

### 2. Системная инженерия. Понятие системы. Варианты рассмотрения систем. Модульность. Жизненный цикл. Операционное окружение и обеспечивающие системы. Заинтересованные стороны (stakeholders). Проблема передачи информации при разработке компьютерных систем.

**Системная инженерия** -- подход, позволяющий реализовывать успешные системы. Это про понятие системы, рассмотрение систем как таковых и как вообще разрабатывать успешные системы.

Идея: Когда разрабатываем большую системы, нам нужно вовлечь представителей разных дисциплин, в большом кол-ве, согласовать между собой и чтобы результат их работы собрать в единое целое.

Cистема - конструкция из взаимодействующих компонентов

Систему можно рассматривать:
- как совокупность частей
	- система разбивается на подсистемы, подсистемы разбиваются на свои подсистемы и тд
- как функциональное место
	- уровень (под)системы зависит от функционального места
	- функциональное место определяется `stakeholder`'ом
	- операционное окружение
		- окружение, в котором развёртываются системы
		- другие системы, на которые полагается (зависит) система
- как жизненный цикл
	- эволюция системы; от концепции до вывода из эксплуатации

Стадии ЖЦ:
1. Концептуальный этап (проектирование, планирование)
2. Этап разработки (тех. документация, спецификация)
3. Этап производства (получения продукта: exe, или физическая приблуда)
4. Этап утилизации
5. Этап поддержки (`<- тут взаимодействие с операционным окружением`)
6. Этап вывода из эксплуатации

**Операционное окружение** -- окружение, в котором развёртываются системы и в которой есть другие системы, на которые полагается (зависит) наша система.

**Обеспечивающая система** -- система, которая дополняет интересующую систему на этапах её ЖЦ (но не обязательно вносит вклад)
`Любая система, продвигающая нашу систему по стадиями жизненного цикла.`

Операционное окружение -- специфический вид обеспечивающей системы.
Обеспечивающая система работает на протяжений ЖЦ и нужна для обеспечения существования этой системы, а операционное окружение -- её эксплуатацию. +- синонимы, но другие требования

**Stakeholder** (заинтересованная сторона) -- лицо (физическое или юридическое), которое так или иначе имеет интерес к нашей система.

>интерес != система удалась

>интерес == как могут влиять на характеристики системы

Stakeholder формирует точку зрения на систему, определяет структуру, приоритеты и тд

Пример Stakeholder'ов:
- Пользователи
- Бизнес, который запускает систему
- Разработчик

**Проблемы разработки компьютерных систем**
1. формулирование/генерация информации,
2. передача/сохранение информации,
3. использование информации.
4. а также: неполнота, неоднозначность, нераспределённость, противоречивость, решению других проблем... 

Проблема передачи информации:
>(ну тут пример про джуна, который узко мыслит, и про всяких аналитиков, которые тоже дэбилы)

### 3. Цели и задачи архитектурного проектирования компьютерных систем, его эффект. Понятие архитектуры. Различные трактовки (Гради Буч, ISO 42010 и д.р.) и их практическая значимость.

ЦЕЛЬ (В идеале): 
- разрабатывать системы быстрее 
- дешевле

В реале:
- предсказуемость проекта
- укладываемся в дедлайны
- СНИЗИТЬ ПРОЕКТНЫЕ РИСКИ
 
**Архитектура** (Eoin Woods) - это набор проектных решений, которые, если они будут приняты неправильно, могут привести к краху проекта.

> Ключевыми особенностями архитектуры системы являются ее многочисленные представления. Например, UML, который включает в себя множество типов диаграмм для описания системы для различных целей.

Архитектура (Гради Буч) -- логическая и физическая структура компонентов системы и их взаимосвязи, сформированные всеми стратегическими и тактическими проектными решениями, применяемыми во время разработки.

*Логическая* -- то, что мы написали в программе, конфигурации etc. (устанавливает существование и роль ключевых абстракций и механизмов, которые **будут** определять архитектуру и общий дизайн системы)  
*Физическая* -- то, связка различных машин/компов (описывает конкретный программный и аппаратный состав реализации системы)

Архитектура (ISO 42010) -- фундаментальная организация и свойства системы, воплощённые в её элементах, отношениях, принципах развития и проектирования  
^(более абстрактная штука)

Фундаментальная организация системы:
- нет универсального правила для определения фундаментальной или нефундаментальной состовляющей
- всегда нужно разбираться по месту

Архитектурное описание -- документ, описывающий архитектуру системы (документация). Может быть, а может отсутствовать.

Архитектура -- всё важное :D (шуточное определение)

### 4. Реле как базис компьютерной системы. Область применения и принципы построения систем на базе реле. Примеры релейных схем и принцип их функционирования. Программируемые логические контроллеры (ПЛК). Область применения. Особенности аппаратуры и программирования по сравнению с компьютерами общего назначения.

По факту, реле -- это автоматический выключатель, который соединяет или разъединяет электроцепи при достижении установленных значений или под внешним воздействием.

Реле ~ транзистор (но транизстор меньше, потребляет меньше электроэнергии, собирается на кремнии)

Самое простое реле:
- магнитная катушка
- можно подать ток
- катушка начнёт примагничивать
- цепь замыкается

Виды:
- механические
- тепловые (чайник)
- оптические
- ...

Реле имеет нормальное состояние и управляющий ~~СИГНАЛ~~

Применения реле:
- `разработка систем управления` ; когда надо управлять силовыми линиям (не логику реализовываем, а управляем процессами)
- неблагоприятная среда эксплуатации
- где электроника не работает (неэлектрические реле)
- в ПЛК (программируемые логические контроллеры)

Проблемы релейных схем:
- плохо масштабируется,
- сложная настройка и поддержка,
- ненадёжность сложных схем,
- проблема ведения документации.

RS-Trigger:
```
L1                      L2
o                       o
|        R         Q    |
+---+---[ ]---+---(\)---+
|   |         |         |
|   |         |         |
|   +---[ ]---+         |
|        NQ             |
|                       |
|        Q              |
|   +---[ ]---+         |
|   |         |         |
|   |         |         |
+---+---[ ]---+---(\)---+
|        S         NQ   |
|                       |
```


ПЛК *(специальная разновидность электронной вычислительной машины)*

*?? есть память ??*

Особенности:
- Компактная штука (легче разбираться, конфигурировать и тд)
- ориентированы на управляющие системы;
- для встроенного использования;
- специализация ввода-вывода, модульность;
- эксплуатация в тяжёлых условиях.

Программирование ПЛК:
- Релейные контактные схемы
- Функциональные блоковые диаграммы (для элементов более сложного управления)
	- На взаимодействии блоков (Двигатель например)
- Последовательностные функциональные диаграммы (Конечные автоматы)
- Структурированный текст (ЯП)

### 5. Принципы кодирования информации в компьютерных системах. Двоичный код, достоинства и недостатки. Машинное слово и адресация. Код грея, BCD, Base64, Base58.

В компьютерных системах -- двоичная система
Используется Булев базис: `И, ИЛИ, НЕ`

Кодирование:
```
+-----------+
|   HIGH    |  <- 1
+-----------+
|           |
| FORBIDDEN |  <- Граница
|           |
+-----------+
|    LOW    |  <- 0
+-----------+

```
 
 Достоинства:
 - Надежность и помехоустойчивость
 - Простая арифметика
 - Диапазоны и точность (разрядность)
 - Погрешность by design, а не by implementation

Недостатки:
- НЕЧИТАЕМО
- Дроби записывается в виде бесконечных дробей (`0.1 + 0.2 != 0.3`)
- Дискретное кодирование сигналов (точность) -- хз

Машинное слово -- единица данных, естественных для обработки вычислителем.
- Позиционные системы счисления
- Доп. код
- Big endian
	- 0xCAFEBABE -> \[CA | FE | BA | BE]
- Little endian
	- 0xCAFEBABE -> \[BE | BA | FE | CA]

Код Грея -- два соседних значения отличаются только на один бит (делает **`помехоустойчивым`**, т.к. если один бит исказится, то значение поменяется не сильно)

BSD -- форма записи рациональных чисел, когда каждый десятичный разряд числа записывается в виде его четырёхбитного двоичного кода

Base64 -- стандарт кодирования двоичных данных при помощи только 64 символов ASCII. Алфавит кодирования содержит:
- A-Z, a-z 
- цифры 0-9 
- 2 дополнительных символа.

*Позволяет записать бинарную информацию в виде символов*

Base58 -- как Base64, но использует меньше символов, имеет в конце записи хэш-сумму

### 6. Что такое комбинационная схема? Построение через таблицу истинности и алгоритмизацию. Состояние и параллелизм, переходные процессы. Состояние `x` и `z`. Особенности поведения комбинационных схем по сравнению с программами. Реализация "условного оператора". Программируемые логические интегральные схемы (ПЛИС) и их устройство.

Комбинационная схема -- схема, составленная из набора логических элементов, в совокупности реализующая заданную таблицу истинности.

Можем построить через 
- таблицу истинности
	- записывает в виде ДНФ или КНФ
	- минимизируем (сокращаем размер схемы)
	- НО РАСТËМ ОЧЕНЬ БЫСТРО
- алгоритмизацию
	- строится на основе понимания функции (взаимосвязь входы и выходы)

Свойства КС:
- Должна приходить в стабильное состояние (со временем)
	- *(установления стабильного состояния при корректном входе)*
	- ИСКЛЮЧЕНИЕ: циклические схемы
- У всех КС есть какая-то задержка (определяет тактовую частоту)
- Накопление ошибки в физ. процессе (коды и буфера помогают)
- `параллелизм уровня бит` 
	- Вид параллилизма, основанный на ширине машинного слова
	- позволяет выполнять несколько операций одновременно на уровне отдельных бит
	- Спекулятивное исполнение
	- Вычислительный конвейер
- уровень линии (НЕ СИГНАЛ)

Состояния сигнала:
- 0 и 1
- z - отключено (провод висит)
	- используют, когда элемент цифровой схемы не участвует в формировании выходного сигнала.
- x -  неизвестно/неопределено
	- используется для обозначения неопределенного состояния
	- деление на 0
	- корень из отриц. числа
	- ...

Условный оператор:
- Спекулятивные вычисления
```python
# Вычисляется два значения, а потом уже решается какой вернуть
int0 = f0(...)
int1 = f1(...)

out = int0 if sel else int1
```

Состояние КС:
- Сохраняется благодаря Триггеру
- Триггер позволяет ограничить распространение сигнала по схеме.
    - Разорвать цикл.
    - Сократить задержку в комбинационной схеме.
    - (чтобы, например, по конвейеру обрабатывать)
- Зафиксировать состояние линии на длительное время.

Многотактовые схемы
- Конвейерное исполнение
	- Количество стадий — количество параллельных задач
	- Больше "разбиений" — ниже задержка схемы, выше частота.
- Пространственные и временные вычисленения
	- для сложения 16-битных чисел можно использовать либо 1 16-битный сумматор, либо 2 8-битных сумматора, но делать две итерации
- Синхронная схемотехника
	- меньше гонок
	- частота по самой медленной КС
	- НО: дискретизация входных сигналов по времени
		- чтобы наблюдать аналоговый сигнал, нужно иметь частоту в 2 раза больше, иначе не поймём что сигнал периодичный
	- НО: синхронность -- в заданном диапазоне
		- сигналы не приходят одновременно
- Программное управление

Отличия КС и программирования:
- Процессы между регистрами происходят параллельно. 
- Передача сигнала — физический аналоговый процесс. 
	- Есть питание и контакт — есть передача. 
	- Сигнал не может не идти.
- Нет понятия "система остановилась". 
	- Она всегда работает, если есть питание.
- Таблица истинности неполна — результат будет случайным, но будет всегда (и возможно воспроизводимым).  

ПЛИС
- интегральные схемы, которые могут быть переконфигурированы после изготовления.
- Логика работы через программирование, а не на производстве
- Пример: Verilog

### 7. 2-этапное производство. Понятия Hardware и Software, их свойства. Сравнение с понятиями программного и аппаратного обеспечения. Проблемы, специфичные для аппаратного обеспечения: производство, эксплуатация, устаревание. Принципы совместного проектирование (HW/SW CoDesign).

2-этапное производство:
- Производство "универсальной" компьютерной системы (`hardware`)
	- не вносим изменения
	- не адаптируем под наши задачи
	- но переиспользуем адаптируя программным обеспечением
- Настройка прикладного поведения (`software`)

Для обеспечения 2-этапного производства:
- заранее определяем возможность "конфигурации"
	- на этапе сборки
	- на этапе реконфигурации
		- меняем схемотехнику подключения элементов друг к другу => получаем новые возможности
		- (есть простейшие логические устройства, можем их менять и получать разный функционал)
	- программирование

`Hardware` — то, что тяжело/долго/дорого поменять  
`Software` — то, что легко/быстро/дешево поменять


Software -- часть компьютерной системы
- приспосабливает технику к различным видам использования
	- На одном и том же компьютере, но с разным программным обеспечением, вы можете играть в игру, рассчитывать налоги, писать письмо или книгу, или получать ответы на вопросы о свиданиях.


Программная система -- система состоящая из ПО, АО и спец. данных, которые важны для системы (например: текстуры для игры, шрифты для ворда и тд)

Проблемы, специфичные для АО:
- Производство
	- Логистика
	- Cклады
	- Специалисты
	- Производственная цепочка
	- Тестирование
	- Упаковка
	- Дистрибуция
	- Гарантийный ремонт
- Эксплуатация
	- Выход оборудования из строя
	- Необходимость физического доступа
	- Особенности среды эксплуатации
	- ?? долгосрочные эффекты ??
- УСТАРЕВАНИЕ
	- Срок службы. Деградация надёжности. Стоимость обслуживания
	- Ремонт требует запасных компонентов.
- Обновление
	- Сложность вносить изменения
	- Не всегда есть доступ, дорого ...

// этого пункта в вопросе нет  
// добавлено на всякий случай
*Свойства программного обеспечения*
1. *Быстрый цикл разработки.*
2. *Легко заменяется (обновляется) прямо у пользователя.*
3. *Пользователь как Beta-тестер.*
4. *Процесс создания и внедрения ПО автоматизируется (CI/CD).*
5. *Высокая сложность программ.*

Классический подход
- HW и SW решают разные задачи, разрабатываются последовательно
- Затягивает сроки, излишняя шаблонность
- Изначально разрабатываются порозень

Hardware/Software CoDesign:
- Проектирование системы в целом
- Совместная разработка, параллельный дизайн и проектирование

Преимущества HW/SW CoDesign
- Более низкая стоимость
- БOльшая производительность
- Улучшенная интеграция между аппаратным и программным обеспечением

### 8. Понятие модели вычислений (MoC). Сопоставление понятия парадигмы программирования и MoC. Примеры MoC (последовательные, параллельные, функциональные) и их роль в разработке компьютерных систем. Использование MoC в разных вычислительных платформах.

**MoC**
- определяет возможности вычислительной машины
- характеризует как исполняется программа
	- какие могут быть состояния вычислителя
	- их последовательность
	- правила переходов (необязательно детерминированное)
- вычисляется результат математической функции с учетом входных данных.
- организованы единицы вычислений, памяти и связи.

Примеры:
- Последовательные (позволяют описать последовательные процессы) 
	- Конечные автоматы
	- Нажимные автоматы
	- Машина Тьюринга
	- von Neumann Machine
- Функциональные(вычислительныие процессы представляются в символьной форме): 
	- Лямбда-исчисление 
	- Общие рекурсивные функции 
	- Комбинаторная логика 
	- Системы переписывания абстрактных текстов.
- Параллельные модели, (используется, когда процесс взаимодействует с другими процессами):
	- Клеточный автомат
	- Технологические сети Кана – Сети Петри
	- Синхронный Поток Данных – Сети взаимодействия
	- Модель-актер.
	  
Роль MoC в разработке компьютерных систем:
- Позволяют анализировать производительность, параллелизм и оптимизировать выполнение программ.
- Улучшают понимание и эффективность различных вычислительных задач.
- Спецификация поведения
	- точно определить и описать поведение компьютерной системы.
- Анализ производительности
	- помогают анализировать и прогнозировать производительность компьютерных систем, `выявлять узкие места`
- Архитектурное проектирование
	- Модели вычислений служат основой для проектирования архитектуры компьютерных систем, определяя их структуру, организацию памяти, способы обработки данных и т.д.
- Разработка алгоритмов 
	- из-за оценки сложности и применимости алгоритма (к конкретной задаче)
- Верификация и тестирование 
	- служат основой для формальной верификации корректности компьютерных систем и их тестирования на соответствие спецификациям.

Использование MoC в разных вычислительных платформах:
- `Модель фон Неймана` лежит в основе архитектуры большинства современных процессоров
- ...

### 9. Универсальный процессор и его свойства. Машина Тьюринга и полнота по Тьюрингу. Виды процессоров (СБИС, FPGA, CGRA, GPU, DSP, CPU) и их сопоставление с точки зрения универсальности и эффективности.

Универсальный процессор  
Позволяет решать широкий круг задач, настройка которых производится после производства "по месту" или в run-time.

Свойства:
- 2-этапное производство
- Полнота по Тьюрингу
- Изменяемое ПО RT
- Отсутствие серьезных ограничений на объем программы

Машина Тьюринга
- это абстрактная вычислительная машина
- которая была предложена Аланом Тьюрингом
- состоит из
	- бесконечной ленты с ячейками;
	- автомата или головки для чтения и записи;
	- программы.
- *может выполнить любое вычисление при наличии времени и памяти*

Полнота по Тьюрингу означает, что
система может эмулировать работу другой универсальной системы  
(что делает ее способной к выполнению любого алгоритма)

**Виды процессоров**
- СБИС (ASIC) (сверхбольшая интегральная схема)
	- схема специального назначения, решение конкретной задачи
	- отсутствие гибкости, но большая энергоэффективность
	- выполняют конкретную узкую задачу
- FPGA (Field-Programmable Gate Array/программируемые вентильные матрицы)
	- возможность конфигурации производителем или разработчиком после изготовления
	- гибкие => могут быть перепрограммированы для выполнения специфических функций
	- В этом смысле, могут быть универсальными (хотя эффективность может изменяться)
- CGRA
	- аппаратные устройства (ускорители)
	- состоит из множества больших функциональных блоков, между которыми выстроена коммуникация (`из них строится программируемый вычислитель`)
	- для обработки сигналов и выполнения задач, требующих высокой степени параллелизма
	- *компромисс между FPGA и процессорами параллельной обработки вида GPU*
- GPU (графические процессоры)
	- Проектировались для обработки графики
	- но параллельные выч. возможности привели к 
		- использованию в области ML 
		- параллельные вычисления. 
	- эффективны в параллельных задачах, но могут быть ограничены в выполнении некоторых последовательных задач.
	- высокая эффективность благодаря конвейерной архитектуре
	- но имеет ограниченный набор команд
- DSP
	- Специализированы на обработке сигналов
	- имеет программируемую логику
	- но имеет экзотический набор команд и инструкций
	- циклическая архитектура с циклом определенной длины
- CPU
	- универсальная схема
	- предназначен для выполнения широкого спектра задач
	- с программируемой логикой
	- низкой энергоэффективностью (но в зависит от задачи)

### 10. Архитектура фон Неймана. Принципы. Свойства. Особенности и ограничения. Применение на практике. Машинное слово. Понятие системы команд и её роль в построении процессоров. Control Unit и DataPath.

Архитектура фон Неймана
- эволюция машины Тьюрина, НО
- есть RAM (чтение и запись в произвольные ячейки памяти)
- однородное хранение программы и данных (Объединены инструкции и данные)
- Полнота по Тьюрингу
- Простота в реализации

Особенности:
- двоич. кодирование (и 3-чное, 2-10 кодировние)
- Последовательное выполнение
- Память однородна для программ и данных
- RAM (адреса ячеек памяти, доступ по адресам) **(не мотаем ленту)**
- Возможность условного переходов и циклов

На практике
- В чистом виде не встречается 
	- много параллельности
	- проц сам решает выполнение, 
	- память не пассивный элемент (может сказать отстань я занята)
- Огромное влияние в большинстве процов
- *ООП - наследие фон Неймана*
- *Ловушка обратной совместимости (все завязано на этом, перейти к другому крайне сложно)*

Машинное слово - фрагмент данных фиксированного размера, обрабатываемый как единое целое

Система команд - некий промежуточный уровень трансляции между прикладной задачей и интерпретацией процессора

Система команд
- (Instruction Set Architecture — ISA) 
- абстрактная модель процессора
- формирует интерфейс взаимодействия между ПО и процессором

Описывает
- типы данных
- модель памяти, система и методы адресации
- набор инструкций
- механизмы обработки прерываний и исключений
- методы ввода и вывода.

ISA зависит от архитектуры процессора:
- произвольной сложности и длины (CISC)
- фиксированного формата (RISC) (действия над памятью/регистрами)
- Действие без указания обрабатываемых данных (стековый)
	- (отсутствие инструкций, но полон по Тьюрингу)
- Управляющие сигналы процессора под видом команды (NISC)
	- (нет кодов и регистров, просто прямые сигналы процессору)
- Группа команд под видом одной команды (VLIW)
	- (ориентировано на параллельную обработку)
- Действие над шиной данных (TTA) 
	- (кодируют не действие, перекидывают данные между вычислительными блоками)
- Команды без последовательного исполнения (редукционные)
	- (программа в памяти, но не определяет команды для исполнения и их порядок)
- Система команд из одной команды (URISC) 
	- (1 возможная команда, но Тьюринг полные)
- Управляющие сигналы процессоров под видом команды (NITTA)

Control Unit
- компонент процессора
- управляет его работой. 
- преобразует закодированные **инструкции в сигналы** управления и синхронизации

Реализации:
- Hardwire 
	- декодирование при помощи аппаратных схем
	- простота за счет системы просто конечных автоматов
	- но растет по сложности от системы команд)
- Microcoded 
	- декодирование при помощи микропрограммы
		- По сути **битовая маска. При этом для каждой инструкции - свой набор микрокоманд**
		- *программа, реализующая набор инструкций процессора, делает из инструкций в памяти микро-операции (управляющие сигналы) и подает их на Control Unit) с необходимыми функциями).* 
    - Просто в реализации
    - Просто вносить изменения
    - Микрокод в процессоре 
	    - занимает место 
	    - разнооборазие архитектур (поэтому много проблем с адаптацией к каждому отдельному)
	    - разнообразие команд (сложно оптимизировать, инструментарий)
	    - все проблемы программирование (отладка)

Datapath - набор компонентов, обеспечивающих передачу и управление данных между компонентами процессора (регистры, шины, алу)

### 11. Гарвардская архитектура и её отличия от архитектуры фон Неймана. Принципы. Свойства. Особенности и ограничения. Применение на практике. Подходы к обходу ограничений архитектуры. Машинное слово. Control Unit и DataPath.

Гарвардская архитектура
- разделение данных и команд (2 разных физических канала)
- В теории производительнее (два канала), безопаснее
- Можно делать разный размер машинного слова и адреса
- Оптимизация под решаемую задачу (так как обособленность программ от данных)
- Сложность (и стоимость) в реализации
- Изоляция памяти и инструкций (безопасность доступа)

Вариации ГА
- Память инструкций как данные
	- чтение и запись данных в память программ
	- позволяет генерить и запускать машинный код
- Память данных как инструкции
	- запуска инструкций из памяти данных
	- позволяет генерить и запускать машинный код
	- но параллельный доступ ограничен.
- Модифицированная ГА
	- использование кэшей данных и программ для доступа к памяти
	- использует физически 1 канал
	- но с внутренней организации процессора доступ независимый

Control Unit
- компонент процессора
- управляет его работой. 
- преобразует закодированные **инструкции в сигналы** управления и синхронизации

Реализации:
- Hardwire 
	- декодирование при помощи аппаратных схем
	- простота за счет системы просто конечных автоматов
	- но растет по сложности от системы команд)
- Microcoded 
	- декодирование при помощи микропрограммы
		- По сути **битовая маска. При этом для каждой инструкции - свой набор микрокоманд**
		- *программа, реализующая набор инструкций процессора, делает из инструкций в памяти микро-операции (управляющие сигналы) и подает их на Control Unit) с необходимыми функциями).* 
    - Просто в реализации
    - Просто вносить изменения
    - Микрокод в процессоре 
	    - занимает место 
	    - разнооборазие архитектур (поэтому много проблем с адаптацией к каждому отдельному)
	    - разнообразие команд (сложно оптимизировать, инструментарий)
	    - все проблемы программирование (отладка)

Datapath - набор компонентов, обеспечивающих передачу и управление данных между компонентами процессора (регистры, шины, алу)

### 12. Механизм микроопераций, микропрограммирование и его роль в развитии компьютерных систем. Особенности и ограничения. Применение на практике. Пример оптимизации через микрокод. NISC архитектура.

Механизм микроопераций
- метод управления операциями в процессор
- каждая инструкция разбивается на более мелкие операции называемые `микрооперациями`.

Микропрограммирование 
- способ управления выполнением микроопераций путем использования микропрограммы
- представляет собой последовательность микроопераций для выполнения каждой инструкции.

Роль микропрограммирования в развитии КС
- позволяет создавать более гибко настраивать поведение процессора (не трогая сам процессор)
- т.к. изменение микропрограммы позволяет изменить поведение процессора без изменения аппаратной части. 
- упрощает разработку новых процессоров и обновление существующих.

- просто в реализации (CISC)
- есть доступ программиста
- гибкость
- Микрокод в процессоре (занимает место)
- сложно в изучении
- проблем с адаптацией (разнооборазие архитектур) 
- разнообразие команд (сложно оптимизировать, инструментарий)
- все проблемы программирование (отладка)

NISC - компьютерная архитектура для специалиированных процессоров, дает прямой контроль компилятору над аппаратными ресурсами, имеет узкое использование типо спец. вычислителях, ускорителях (отказ от системы команд и инструкций, использование напрямую системы микрокоманд)

- Упрощение аппаратуры (убрать интерпертаторы инструкций)
- Высокая эффективность управления (нет системы команд - нет ее проектирования и архитектуры)
- Нет архитектуры системы команд (ISA) - нет проблем с ней
- Низкая плотность машинного кода ()
- Сложно организовать совместимость для процессоров общего назначения

Оптимизация через микрокод
- процесс оптимизации работы процессора 
- путем изменения или добавления микроинструкций
- *если определенная последовательность инструкций выполняется неэффективно -- разработчики создают новую*

NISC
- компьютерная архитектура для специалиpированных процессоров
- дает прямой контроль компилятору над аппаратными ресурсами
- имеет узкое использование (спец. вычислителях, ускорителях)
- отказ от системы команд и инструкций 
- использование напрямую системы микрокоманд)

Св-йства
- Упрощение аппаратуры (нет интерпертатора инструкций)
- Высокая эффективность управления
	- нет системы команд - нет ее проектирования и архитектуры
- Нет архитектуры системы команд (ISA) - нет проблем с ней
- Низкая плотность машинного кода
- Сложно организовать совместимость для процессоров общего назначения

### 13. Что такое CISC? Роль в развитии компьютерных систем. Применение на практике. Достоинства и недостатки. Отличия от архитектуры фон Неймана. Особенности программирования.

CISC - компьютерная архитектура
- отдельная инструкция может выполнять несколько операций низкого уровня 
- или многошаговые операции (будь то загрузка из/в память, арифм. операции и т.д.). 
- Больше и разнообразнее система команд

**хочешь писать мало - пиши команды мощнее**

Подходы к реализации CU:
- hw
	- при помощи аппаратных комбинационных схем, декодирующих инструкции в последовательности сигналов.
- mc
	- при помощи исполнения микропрограммы, реализующей необходимые функции.
- микропрограмма (микрокод)
	- программа, реализующая набор инструкций процессора.

+:
- меньше инструкций на low-level языках
	- удобство испльзование asm-a
- унификация системы команд для разных архитектур
- Неразвитость компиляторов - необходимость писать на низком уровне
- Высокая производительность (т.к. низкоуровневые языки)
- реализовать операции с произвольным набором аргументов, к примеру инструкцию для расчета многочленов в рамках одной инструкции

-:
- Сложная система команд (использовать и анализировать)
- долгое исполнение инструкции (команды **можно** заменить группой)
- Усложнение устройства процессора и Control Unit (из-за числа команд)
- сложно генерировать эффективный машинный код
	- Из-за навороченности инструкций в командах и сложности написания компиляторов под систему команд каждого процессора 
- сложность растет комбинаторно

Отличия от архитектуры = подвох
Нейман (и Гарвард) - организация памяти, а не арх. процессора
Нейман не отвечает систему команд, регистры и тд


